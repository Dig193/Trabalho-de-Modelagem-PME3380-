import numpy as np
import matplotlib.pyplot as plt

from scipy.integrate import solve_ivp

# Parâmetros fixos (resistências, complacência e indutâncias)
R_cp, R_cs = 0.1, 1
C_cp, C_cs, C_ae, C_ad = 20, 50, 2.5, 3
L_cp, L_cs = 0.0001, 0.0001

# Parâmetros da simulação
tf = 20                    # [s]
steps = 50000
t = np.linspace(0, tf, steps)
tl = 5                    # tempo de observação

# Condições iniciais
q_ad = 30                 
q_vd = 70                 
q_ae = 50                 
q_ve = 90                
q_cp = 400                                 
i_cp = 0.0                 
i_cs = 0.0
q_0 = 5000

x0 = np.array([q_ad, q_vd, q_ae, q_ve, q_cp, i_cp, i_cs])

# Função das complacências variáveis
def compl(TC, c_vd, c_vs, bpm = 80):
    Tl = 60/bpm
    zeit = TC % Tl
    tc = 0.3*Tl
    tr = 0.25*Tl
    if 0 <= zeit < tc:
        f = 0.5*(1-np.cos(np.pi*zeit/tc))
    elif tc <= zeit < tc + tr:
        f = 0.5*(1+np.cos(np.pi*(zeit-tc)/tr))
    else:
        f = 0
    c = 1/(1/c_vd+f*(1/c_vs-1/c_vd))
    return c

def P_v(td,P_0, P_max, bpm=80):
    Tr = 60/bpm
    cont = td % Tr
    if 0 <= cont <= 0.2*Tr:
        Pres = P_0 + 0.5*(P_max-P_0)*(1-np.cos((np.pi*cont/(0.2*Tr))))
    elif 0.2*Tr <= cont <= 0.43*Tr:
        Pres = P_0 + 0.5*(P_max-P_0)*(1+np.cos((np.pi*(cont-0.2*Tr)/((0.43-0.2)*Tr))))
    else:
        Pres = P_0
    return Pres

def P_cp(td,P_0, P_max, bpm=80):
    Tr = 60/bpm
    cont = td % Tr
    A = 10.95
    B = P_0 + 0.5*(P_max-P_0)*(1-np.cos((2*np.pi*(0.85*Tr/3-0.08*Tr)/(Tr/3))))
    D = (np.pi*(P_max-P_0)/0.08*Tr)*np.sin((2*np.pi*(0.85*Tr/3-0.08*Tr)/(Tr/3)))
    C =D/(A-B)
    if 0 <= cont <= 0.08*Tr:
        Pres = P_0
    elif 0.08*Tr <= cont <= 0.85*Tr/3:
        Pres = P_0 + 0.5*(P_max-P_0)*(1-np.cos((2*np.pi*(cont-0.08*Tr)/(Tr/3))))
    else:
        Pres = A + (B-A)*np.exp(-C*(cont-0.85*Tr/3))
    return Pres

def P_cs(td,P_0, P_max, bpm=80):
    Tr = 60/bpm
    cont = td % Tr
    r = 0.56
    u = 1.2
    K = 1.02808998
    o=(K*r+u*(K-1))/(2*K-1)
    p=1/(r+u-2*o)
    a = 0.5*(P_max-P_0)*p*np.pi/(0.2*Tr)*np.sin(p*np.pi*(u-o))
    b = P_0 + 0.5*(P_max-P_0)*(1-np.cos((p*np.pi*(r*0.2*Tr-o*0.2*Tr)/(0.2*Tr))))
    c = P_0 + 0.5*(P_max-P_0)*(1-np.cos((p*np.pi*(u*0.2*Tr-o*0.2*Tr)/(0.2*Tr))))
    if 0 <= cont <= r*0.2*Tr:
        Pres = a*(cont-r*0.2*Tr)+b
    elif r*0.2*Tr <= cont <= u*0.2*Tr:
        Pres = P_0 + 0.5*(P_max-P_0)*(1-np.cos((p*np.pi*(cont-o*0.2*Tr)/(0.2*Tr))))
    else:
        Pres = a*(cont-u*0.2*Tr)+c
    return Pres

#Função das resistências entre ventrículos e circulações:
def res_ext(t, nom, sat=100, bpm = 80):
    Tr = 60/bpm
    tempo = t % Tr
    r = 0.56
    u = 1.2
    if r*0.2*Tr <= tempo <= u*0.2*Tr:
        Re = nom
    else:
        Re = sat
    return Re

#Função das resistências entre átrios e ventrículos:
def res_int(t, NOM, SAT=100, bpm = 80):
    Per = 60/bpm
    TEMPO = t % Per
    if 0 <= TEMPO <= 0.48*Per:
        Ri = SAT
    else:
        Ri = NOM
    return Ri

def Lin(t, x):
    C_vd = compl(t, 15, 1)
    C_ve = compl(t, 12, 0.5)
    P_ad = 5 - P_v(t, 5, 22, 80)
    P_vd = P_v(t, 5, 22, 80) - P_cp(t, 11, 17, 80)
    P_ae = 10 - P_v(t, 10, 100, 80)
    P_ve = P_v(t, 10, 100, 80) - P_cs(t, 60, 95, 80)
    R_ad = res_int(t, 0.01, 100, 80)
    R_vd = res_ext(t, 0.01, 100, 80)
    R_ae = res_int(t, 0.02, 100, 80)
    R_ve = res_ext(t, 0.02, 100, 80)
    Sol = [(-1/(C_ad*R_ad))*x[0] + (1/(C_vd*R_ad))*x[1] - x[6] - (P_ad/R_ad),
          (1/(C_ad*R_ad))*x[0] + (-1/(C_vd))*((1/R_ad)+(1/R_vd))*x[1] + (1/(C_cp*R_vd))*x[4] + (P_ad/R_ad) - (P_vd/R_vd),
          (-1/(C_ae*R_ae))*x[2] + (1/(C_ve*R_ae))*x[3] - x[5] - (P_ae/R_ae),
          (-1/(C_cs*R_ve))*x[0] + (-1/(C_cs*R_ve))*x[1] + ((1/(C_ae*R_ae))+(-1/(C_cs*R_ve)))*x[2] + ((-1/(C_ve*R_ve))+(-1/(C_ve*R_ae))+(-1/(C_cs*R_ve)))*x[3] + (-1/(C_cs*R_ve))*x[4] + (P_ae/R_ae) - (P_ve/R_ve) + (q_0/(C_cs*R_ve)),
          (1/(C_vd*R_vd))*x[1] + (-1/(C_cp*R_vd))*x[4] + x[5] + (P_vd/R_vd),
          (1/(C_ae*L_cp))*x[2] + (-1/(C_cp*L_cp))*x[4] - (R_cp/L_cp)*x[5],
          (1/(L_cs))*((1/C_ad)+(1/C_cs))*x[0] + (1/(C_cs*L_cs))*x[1] + (1/(C_cs*L_cs))*x[2] + (1/(C_cs*L_cs))*x[3] + (1/(C_cs*L_cs))*x[4] - (R_cs/L_cs)*x[6] - (q_0/(C_cs*L_cs))]
    return Sol

s_N1 = solve_ivp(Lin, [0, tf], x0, method='RK45', dense_output=True)
x_N1 = s_N1.sol(t)

fig, axs = plt.subplots(nrows=3, ncols=2, figsize=(10, 8))

axs[0,0].plot(t, x_N1[0], 'limegreen', lw=1.5)
axs[0,0].set_xlabel(r'tempo [s]')
axs[0,0].set_ylabel(r'Volume [ml]')
axs[0,0].set_xlim(15,16)
axs[0,0].grid(color='darkgrey', lw=0.5)
axs[0,0].set_title(r'Valores de carga', fontfamily = 'sans-serif', fontsize = 'large')

axs[0,1].plot(t, x_N1[1], 'limegreen', lw=1.5)
axs[0,1].set_xlabel(r'tempo [s]')
axs[0,1].set_ylabel(r'Volume [ml]')
axs[0,1].set_xlim(15,16)
axs[0,1].grid(color='darkgrey', lw=0.5)
axs[0,1].set_title(r'Valores de carga', fontfamily = 'sans-serif', fontsize = 'large')

axs[1,0].plot(t, x_N1[2], 'limegreen', lw=1.5)
axs[1,0].set_xlabel(r'tempo [s]')
axs[1,0].set_ylabel(r'Volume [ml]')
axs[1,0].set_xlim(15,16)
axs[1,0].grid(color='darkgrey', lw=0.5)
axs[1,0].set_title(r'Valores de carga', fontfamily = 'sans-serif', fontsize = 'large')

axs[1,1].plot(t, x_N1[3], 'limegreen', lw=1.5)
axs[1,1].set_xlabel(r'tempo [s]')
axs[1,1].set_ylabel(r'Volume [ml]')
axs[1,1].set_xlim(15,16)
axs[1,1].grid(color='darkgrey', lw=0.5)
axs[1,1].set_title(r'Valores de carga', fontfamily = 'sans-serif', fontsize = 'large')

vec_q0 = np.array(steps*[q_0])
q_cs = vec_q0 - x_N1[0] - x_N1[1] - x_N1[2] - x_N1[3] - x_N1[4]

axs[2,0].plot(t, x_N1[4], 'limegreen', lw=1.5)
axs[2,0].set_xlabel(r'tempo [s]')
axs[2,0].set_ylabel(r'Volume [ml]')
axs[2,0].set_xlim(15,16)
axs[2,0].grid(color='darkgrey', lw=0.5)
#axs[2,0].set_title(r'Valores de carga', fontfamily = 'sans-serif', fontsize = 'large')

axs[2,1].plot(t, q_cs, 'limegreen', lw=1.5)
axs[2,1].set_xlabel(r'tempo [s]')
axs[2,1].set_ylabel(r'Volume [ml]')
axs[2,1].set_xlim(15,16)
axs[2,1].grid(color='darkgrey', lw=0.5)
#axs[2,1].set_title(r'Valores de carga', fontfamily = 'sans-serif', fontsize = 'large')

P_v_d_y = [P_v(T, 5, 22, 80) for T in t]
P_v_e_y = [P_v(T, 10, 100, 80) for T in t]
P_a_d_y = [6 for T in t]
P_a_e_y = [11 for T in t]
P_cp_y = [P_cp(T, 11, 17, 80) for T in t]
P_cs_y = [P_cs(T, 60, 95, 80) for T in t]
R_ad_y = [res_int(T, 0.01, 1000, 80) for T in t]  
R_ae_y = [res_int(T, 0.02, 1000, 80) for T in t]  
R_vd_y = [res_ext(T, 0.01, 1000, 80) for T in t]  
R_ve_y = [res_ext(T, 0.02, 1000, 80) for T in t]  

fig, axs = plt.subplots(nrows=2, ncols=2, figsize=(10, 8))

axs[0,0].plot(t, P_v_d_y, 'limegreen', lw=1.5)
axs[0,0].plot(t, P_a_d_y, 'red', lw=1.5)
axs[0,0].plot(t, P_cp_y, 'blue', lw=1.5)
axs[0,0].set_xlabel(r'tempo [s]')
axs[0,0].set_ylabel(r'Volume [ml]')
axs[0,0].set_xlim(15,16)
axs[0,0].grid(color='darkgrey', lw=0.5)
axs[0,0].set_title(r'Valores de carga', fontfamily = 'sans-serif', fontsize = 'large')

axs[0,1].plot(t, P_v_e_y, 'limegreen', lw=1.5)
axs[0,1].plot(t, P_a_e_y, 'red', lw=1.5)
axs[0,1].plot(t, P_cs_y, 'blue', lw=1.5)
axs[0,1].set_xlabel(r'tempo [s]')
axs[0,1].set_ylabel(r'Volume [ml]')
axs[0,1].set_xlim(15,16)
axs[0,1].grid(color='darkgrey', lw=0.5)
axs[0,1].set_title(r'Valores de carga', fontfamily = 'sans-serif', fontsize = 'large')

axs[1,0].plot(t, R_ad_y, 'limegreen', lw=1.5)
axs[1,0].set_xlabel(r'tempo [s]')
axs[1,0].set_ylabel(r'Vazão [ml/s]')
axs[1,0].set_xlim(15,16)
axs[1,0].grid(color='darkgrey', lw=0.5)
#axs[2,0].set_title(r'Valores de carga', fontfamily = 'sans-serif', fontsize = 'large')

axs[1,1].plot(t, R_vd_y, 'limegreen', lw=1.5)
axs[1,1].set_xlabel(r'tempo [s]')
axs[1,1].set_ylabel(r'Vazão [ml/s]')
axs[1,1].set_xlim(15,16)
axs[1,1].grid(color='darkgrey', lw=0.5)
#axs[2,1].set_title(r'Valores de carga', fontfamily = 'sans-serif', fontsize = 'large')

# Adjust the layout and spacing
fig.tight_layout()

# Show the plot
plt.show()
